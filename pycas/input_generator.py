"""
Input File Generator - Creates input.asc files from simulation configuration
"""

from typing import List, Dict, Any
from .component import Component
from .component_registry import ComponentRegistry


class InputFileGenerator:
    """Generates CADAC input.asc files"""

    def __init__(self, registry: ComponentRegistry):
        self.registry = registry

    def generate(self, simulation_name: str, components: List[Component],
                 initial_state: Dict[str, Any], config: Dict[str, Any]) -> str:
        """
        Generate complete input.asc content

        Args:
            simulation_name: Name of the simulation
            components: List of configured components
            initial_state: Initial state variables
            config: Simulation configuration (duration, dt, etc.)

        Returns:
            Complete input.asc file content as string
        """
        lines = []

        # Header
        lines.append(f"TITLE {simulation_name}")
        lines.append(f"// Auto-generated by pyCAS")
        lines.append("")

        # Options (required before MODULES)
        lines.append("OPTIONS y_scrn n_events n_tabout y_plot n_merge y_doc n_comscrn n_traj")
        lines.append("")

        # Modules section
        lines.append("MODULES")
        for comp in components:
            lines.append(f"    {comp.module_spec}")
        lines.append("END")
        lines.append("")

        # Timing section (match BALL3 format)
        lines.append("TIMING")
        lines.append(f"\tscrn_step {config.get('output_step', 0.1) * 10}")  # Less frequent screen output
        lines.append(f"\tplot_step {config.get('output_step', 0.1)}")
        lines.append(f"\tint_step {config.get('dt', 0.01)}")
        lines.append("END")
        lines.append("")

        # Vehicles section (BALL3 format: VEHICLES 1, then BALL <name>)
        lines.append("VEHICLES 1")
        lines.append(f"\tBALL {simulation_name.upper()}")

        # Initial state
        if initial_state:
            lines.append("\t\t//Initial Conditions")
            for key, value in sorted(initial_state.items()):
                if isinstance(value, (int, float)):
                    lines.append(f"\t\t\t{key}  {value}")
                else:
                    lines.append(f"\t\t\t{key}  {value}")

        # Component parameters
        for comp in components:
            if comp.parameters:
                lines.append(f"\t\t//{comp.name} parameters")
                for param_name, param_value in sorted(comp.parameters.items()):
                    if isinstance(param_value, list):
                        # Handle array parameters (e.g., time_table, pitch_table)
                        for i, val in enumerate(param_value):
                            lines.append(f"\t\t\t{param_name}[{i}]  {val}")
                    elif isinstance(param_value, (int, float)):
                        lines.append(f"\t\t\t{param_name}  {param_value}")
                    else:
                        lines.append(f"\t\t\t{param_name}  {param_value}")

        lines.append("\tEND")

        # ENDTIME marker
        lines.append(f"ENDTIME {config.get('duration', 100.0)}")
        lines.append("STOP")
        lines.append("")

        return '\n'.join(lines)
